## 1. [The Basics](https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html)

   ```swift 
   let swiftIntroduced = "2014"
   ```
   
   #### Glossary
   
  * Type Safety: Type Safety ensures that the code you write does not use or pass incorrect data types. Swift is a type-safe language, which means it performs type checks when compiling your code and flags any mismatched types as errors. This helps prevent bugs and ensures that your code behaves as expected.
  
    Example of a type safety error:
    ```swift
    var age: Int = 25
    age = "twenty-five" // Error: Cannot assign value of type 'String' to type 'Int'
    ```

  * Data types (Int, Float, Double, Bool)
      ```swift
      let numberOfProducts: Int = 25
      let discountRate: Float = 0.15
      let price: Double = 199.99
      let isAvailable: Bool = true
      ```

  * Variables 
    * Type Annotation 
      ```swift
      var productName: String = "Laptop"
      ```
    * Type Inference: Type inference enables the compiler to deduce the type of a variable or constant based on the value assigned to it. This allows you to write cleaner and more concise code without explicitly specifying the type.

      Example of type inference:
      ```swift
      var productName = "Laptop" // inferred as String
      let productPrice = 999.99 // inferred as Double
      ```

  * Constants: Constants are values that, once set, cannot be changed. They are declared using the `let` keyword. Constants are useful when you have values that should remain the same throughout the execution of your program, ensuring that these values are not accidentally modified.

    Example of a compiler error when trying to modify a constant:
    ```swift
    let productName = "Laptop"
    productName = "Smartphone" // Error: Cannot assign to value: 'productName' is a 'let' constant
    ```


  * String
    * String literal 
      ```swift
      let welcomeMessage = "Welcome to PriceCompare!"
      ```
    * Multi-line String 
      ```swift
      let termsAndConditions = """
      By using PriceCompare, you agree to our terms and conditions.
      Please read them carefully.
      """
      ```
    * Special characters / escape characters 
      ```swift
      let specialCharacters = "The product's price is \"\$199.99\""
      ```
    * String initialization syntax
      ```swift
      let emptyString = String()
      let productCategory = String("Electronics")
      ```
    
    * Concatenation
      ```swift
      let brand = "Apple"
      let model = "MacBook Pro"
      let productDescription = brand + " " + model
      ```
    * String interpolation 
      ```swift
      let product = "iPhone"
      let price = 999.99
      let message = "The price of \(product) is $\(price)."
      ```
    * Substrings
      ```swift
      let fullProductName = "Apple iPhone 13"
      let index = fullProductName.firstIndex(of: " ") ?? fullProductName.endIndex
      let brandName = fullProductName[..<index]
      let brand = String(brandName)
      ```
    * Prefix and Suffix
      ```swift
      let productName = "Apple iPhone 13"
      let hasApplePrefix = productName.hasPrefix("Apple")
      let has13Suffix = productName.hasSuffix("13")
      let str = "Apple iPhone"
      str.prefix(5) 
      ```

  * Int 
    ```swift
    let numberOfStores: Int = 42
    ```

  * Float
    ```swift
    let discountPercentage: Float = 0.20
    ```

  * Double 
    ```swift
    let productPrice: Double = 999.99
    ```

  * Boolean 
    ```swift
    let isInStock: Bool = true
    ```

  * Tuples
    ```swift
    let productInfo = (id: 404, name: "Not Found")
    let (productId, productName) = productInfo
    print("The product ID is \(productId)")
    print("The product name is \(productName)")
    ```

    * typealias
      ```swift
      typealias Product = (id: Int, name: String)
      let featuredProduct: Product = (101, "MacBook Pro")
      print("Product ID: \(featuredProduct.id), Name: \(featuredProduct.name)")
      ```

  * Type Casting: Type casting is used to check the type of an instance or to treat that instance as a different superclass or subclass from somewhere else in its class hierarchy. Swift provides two type casting operators: `is` and `as`.

    ```swift
    let integerNumber = 42
    let doubleNumber = Double(integerNumber)
    print("The double value is \(doubleNumber)") // Output: The double value is 42.0
    ```

    * Casting String to Double: You can cast a string to a double using the `Double` initializer. This is useful when you need to perform numerical operations on a value that is stored as a string.

      Example of casting a string to a double:
      ```swift
      let priceString = "199.99"
      if let price = Double(priceString) {
          print("The price is \(price)")
      } else {
          print("Invalid price format")
      }
      ```

    * `is` Operator: The `is` operator is used to check if an instance is of a certain type.
      ```swift
      let item: Any = "Hello"
      if item is String {
          print("item is a String")
      }
      ```

    * `as` Operator: The `as` operator is used to cast an instance to a different type. There are two forms of the `as` operator:
      * `as?`: This form returns an optional value and is used for conditional casting.
        ```swift
        let item: Any = "Hello"
        if let stringItem = item as? String {
            print("item is a String: \(stringItem)")
        }
        ```

      * `as!`: This form forcefully casts the instance to the specified type and should be used with caution as it can cause runtime errors if the cast fails.
        ```swift
        let item: Any = "Hello"
        let stringItem = item as! String
        print("item is a String: \(stringItem)")
        ```

  * String Formatting: String formatting is used to create a formatted string from variables or constants. In Swift, you can use the `String(format:_:)` initializer to create a formatted string. This is particularly useful when you need to control the number of decimal places or include variables in a specific format.

    Example of string formatting:
    ```swift
    let userOneHeight = 70.0 // height in inches
    let height = String(format: "%.1f", Double(userOneHeight) / Double(12.0))
    print("User's height in feet: \(height)") // Output: User's height in feet: 5.8
    ```

    In this example, the `String(format: "%.1f", ...)` initializer is used to format the height in feet to one decimal place. The format specifier `%.1f` indicates that the resulting string should have one digit after the decimal point.

* Enumerations

   ```swift 
   enum NetworkError: Error {
     case decodingError(Error) 
     case badURL(String)
     case badStatusCode(String)
   }
   ```
   
   #### Glossary
   
  * `CaseIterable`
    ```swift
    enum ProductCategory: CaseIterable {
        case electronics, clothing, groceries, books
    }
    let numberOfCategories = ProductCategory.allCases.count
    print("There are \(numberOfCategories) product categories.")
    ```

  * Associated Values
    ```swift
    enum PaymentMethod {
        case creditCard(number: String, expiry: String)
        case paypal(email: String)
    }
    var payment = PaymentMethod.creditCard(number: "1234-5678-9012-3456", expiry: "12/23")
    payment = .paypal(email: "user@example.com")
    ```

  * Raw Values
    ```swift
    enum ProductType: Int {
      case electronics = 1
      case clothing
      case groceries
    }
    let selectedCategory = ProductType.clothing.rawValue
    ```

  * Implicitly assigned Raw Values
    ```swift
    enum ShippingMethod: Int {
        case standard = 1, express, overnight
    }
    let expressShipping = ShippingMethod.express.rawValue
    ```

* Value types (super important)
    
    Value types are types that hold and manage their own data. When you assign or pass a value type, a copy of the data is created. Examples of value types in Swift include structures (struct), enumerations (enum), and tuples. Value types are typically used for data that is not intended to be shared or mutated across different parts of a program.

    ```swift
    var originalPrice = "199.99"
    var discountedPrice = originalPrice
    discountedPrice = "149.99"
    print(originalPrice) // 199.99
    print(discountedPrice) // 149.99
    ```
* Reference types (super important)

  Reference types are types that do not hold their own data, but instead hold a reference to the data. When you assign or pass a reference type, you are passing a reference to the same instance of the data, not a copy. Examples of reference types in Swift include classes and functions. Reference types are typically used for data that is intended to be shared or mutated across different parts of a program.

  ```swift
  class Product {
      var name: String
      var price: Double
      
      init(name: String, price: Double) {
          self.name = name
          self.price = price
      }
  }

  let originalProduct = Product(name: "Laptop", price: 999.99)
  let discountedProduct = originalProduct
  discountedProduct.price = 899.99

  print(originalProduct.price) // 899.99
  print(discountedProduct.price) // 899.99
  ```
***
<br>

* Optionals (super important): Optionals are used in Swift to represent a variable that can hold either a value or no value (nil). They are declared by appending a question mark (?) to the type. Optionals are useful for handling situations where a value may be absent, such as when retrieving data from a network request or user input.

  Example of declaring and using an optional:
  ```swift
  var optionalDiscount: Double? = 0.10
  optionalDiscount = nil
  ```

  You can safely unwrap an optional using optional binding or the nil-coalescing operator to provide a default value if the optional is nil.

  * Optional binding: 
  Optional binding is used to safely unwrap an optional. 
  If the optional contains a value, it is assigned to a constant, and the code inside the if block is executed.
  If the optional is nil, the else block is executed.
  ```swift
  if let discount = optionalDiscount {
    print("Discount is \(discount * 100)%")
  } else {
    print("No discount available")
  }
  
  ```

  
  * nil-coalescing:
  The nil-coalescing operator (??) is used to provide a default value if an optional is nil.
  It unwraps an optional if it contains a value, or returns a default value if the optional is nil.
  This is useful for providing fallback values and avoiding the need for explicit unwrapping.

  ```swift
  let defaultDiscount = 0.05
  let discount = optionalDiscount ?? defaultDiscount
  print("Discount is \(discount * 100)%")
  ```
