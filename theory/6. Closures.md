## 6. [Closures](https://docs.swift.org/swift-book/LanguageGuide/Closures.html)

   ```swift 
   let add: (Int, Int) -> Int = { $0 + $1 }
   add(12, 7) // 19
   ```
   
     
   #### Glossary
   
  * trailing closure syntax
    ```swift
    func applyDiscount(price: Double, discount: (Double) -> Double) -> Double {
      return discount(price)
    }

    let discountedPrice = applyDiscount(price: 199.99) { $0 * 0.9 }
    print(discountedPrice) // 179.991
    ```

  * shorthand-syntax

    Shorthand syntax allows you to write more concise and readable closures by omitting parameter names and return types. Instead, you can use shorthand argument names like `$0`, `$1`, `$2`, etc., to refer to the closure's arguments in the order they are passed.

    ```swift
    let prices = [199.99, 299.99, 399.99]
    let discountedPrices = prices.map { $0 * 0.9 }
    print(discountedPrices) // [179.991, 269.991, 359.991]
    ```

  * capturing values

    In Swift, closures can capture and store references to variables and constants from the surrounding context in which they are defined. This is known as capturing values. The captured values are retained by the closure, allowing it to modify and use them even after the original scope has ended. This is particularly useful for maintaining state within a closure.

    ```swift
    func makePriceIncrementer(incrementAmount: Double) -> () -> Double {
      var total = 0.0
      return {
        total += incrementAmount
        return total
      }
    }

    let incrementByTen = makePriceIncrementer(incrementAmount: 10.0)
    print(incrementByTen()) // 10.0
    print(incrementByTen()) // 20.0
    ```
  * @escaping closure

    In Swift, a closure is said to be escaping if it is called after the function it was passed to returns. This means the closure can outlive the function it was passed to. To indicate that a closure is escaping, you use the `@escaping` keyword before the closure's parameter type. Escaping closures are often used for completion handlers in asynchronous operations.

    ```swift
    var completionHandlers: [() -> Void] = []

    func addCompletionHandler(handler: @escaping () -> Void) {
      completionHandlers.append(handler)
    }

    addCompletionHandler {
      print("Price comparison completed.")
    }

    completionHandlers.first?() // Price comparison completed.
    ```

  * implicit return
    ```swift
    let multiply: (Double, Double) -> Double = { $0 * $1 }
    print(multiply(4.0, 5.0)) // 20.0
    ```

  * multiple trailing closures
    ```swift
    func fetchProductData(success: () -> Void, failure: () -> Void) {
      let isSuccess = true
      if isSuccess {
        success()
      } else {
        failure()
      }
    }

    fetchProductData {
      print("Product data fetched successfully.")
    } failure: {
      print("Failed to fetch product data.")
    }
    ```

    Example of using `typealias` with a closure:
    ```swift
    typealias CompletionHandler = (Bool, String) -> Void

    func fetchData(completion: CompletionHandler) {
        // Simulate a network request
        let success = true
        let message = "Data fetched successfully"
        completion(success, message)
    }

    fetchData { (success, message) in
        if success {
            print(message)
        } else {
            print("Failed to fetch data")
        }
    }
    ```