## 3. [Collection Types](https://docs.swift.org/swift-book/LanguageGuide/CollectionTypes.html)

  ```swift 
  let languages = ["C", "Java", "Objective-C", "Swift", "JavaScript"]
  ```

  #### Glossary

  * Array
    ```swift
    let fruits = ["Apple", "Banana", "Cherry"]
    print(fruits[0]) // Apple
    ```

    * enumerated() example
      ```swift
      let colors = ["Red", "Green", "Blue"]
      for (index, color) in colors.enumerated() {
        print("Color \(index + 1): \(color)")
      }
      // prints Color 1: Red, Color 2: Green, Color 3: Blue
      ```
    
    * Append
      ```swift
      var fruits = ["Apple", "Banana"]
      fruits.append("Cherry")
      print(fruits) // ["Apple", "Banana", "Cherry"]
      ```

    * Insert
      ```swift
      var fruits = ["Apple", "Banana"]
      fruits.insert("Cherry", at: 1)
      print(fruits) // ["Apple", "Cherry", "Banana"]
      ```

    * Remove
      ```swift
      var fruits = ["Apple", "Banana", "Cherry"]
      fruits.remove(at: 1)
      print(fruits) // ["Apple", "Cherry"]
      ```

    * Sort
      ```swift
      var fruits = ["Banana", "Apple", "Cherry"]
      fruits.sort()
      print(fruits) // ["Apple", "Banana", "Cherry"]
      ```

    * Reverse
      ```swift
      var fruits = ["Apple", "Banana", "Cherry"]
      fruits.reverse()
      print(fruits) // ["Cherry", "Banana", "Apple"]
      ```

    * Contains
      ```swift
      let fruits = ["Apple", "Banana", "Cherry"]
      print(fruits.contains("Banana")) // true
      print(fruits.contains("Grapes")) // false
      ``` * Iterate
      ```swift
      let numbers = [1, 2, 3, 4, 5]
      for number in numbers {
        print(number)
      }
      // prints 1, 2, 3, 4, 5
      ```

  * Dictionary
    ```swift
    var capitals = ["France": "Paris", "Japan": "Tokyo"]
    print(capitals["France"]!) // Paris
    // Adding a new key-value pair
    capitals["Italy"] = "Rome"
    print(capitals) // ["France": "Paris", "Japan": "Tokyo", "Italy": "Rome"]

    // Updating a value for a key
    capitals["Japan"] = "Kyoto"
    print(capitals) // ["France": "Paris", "Japan": "Kyoto", "Italy": "Rome"]

    // Removing a key-value pair
    capitals.removeValue(forKey: "France")
    print(capitals) // ["Japan": "Kyoto", "Italy": "Rome"]

    // Iterating over a dictionary
    for (country, capital) in capitals {
      print("\(country): \(capital)")
    }
    // prints:
    // Japan: Kyoto
    // Italy: Rome

    // Accessing all keys
    let allKeys = Array(capitals.keys)
    print(allKeys) // ["Japan", "Italy"]

    // Accessing all values
    let allValues = Array(capitals.values)
    print(allValues) // ["Kyoto", "Rome"]
    ```

  * Set
    ```swift
    let uniqueNumbers: Set = [1, 2, 3, 1, 2]
    print(uniqueNumbers) // [1, 2, 3]
    // Basic Set functions and operations
    var setA: Set = [1, 2, 3, 4, 5]
    var setB: Set = [4, 5, 6, 7, 8]

    // Union
    let unionSet = setA.union(setB)
    print(unionSet) // [1, 2, 3, 4, 5, 6, 7, 8]

    // Intersection
    let intersectionSet = setA.intersection(setB)
    print(intersectionSet) // [4, 5]

    // Subtracting
    let subtractingSet = setA.subtracting(setB)
    print(subtractingSet) // [1, 2, 3]

    // Symmetric Difference
    let symmetricDifferenceSet = setA.symmetricDifference(setB)
    print(symmetricDifferenceSet) // [1, 2, 3, 6, 7, 8]
    ```
    #### Higher Order Functions (super important)

    Higher order functions are functions that take other functions as parameters or return functions as their result. They are a powerful feature in Swift that allows for more abstract and reusable code.

    * `map`
      The `map` function applies a given function to each element of a collection and returns an array containing the results.
      ```swift
      let numbers = [1, 2, 3, 4, 5]
      let squaredNumbers = numbers.map { $0 * 2 }
      print(squaredNumbers) // [2, 4, 6, 8, 10]
      ```

    * `filter`
      The `filter` function returns an array containing only the elements of a collection that satisfy a given predicate.
      ```swift
      let numbers = [1, 2, 3, 4, 5]
      let evenNumbers = numbers.filter { $0 % 2 == 0 }
      print(evenNumbers) // [2, 4]
      ```

    * `reduce`
      The `reduce` function combines all elements of a collection into a single value using a given closure.
      ```swift
      let numbers = [1, 2, 3, 4, 5]
      let sum = numbers.reduce(0) { $0 + $1 }
      print(sum) // 15
      ```

    * `flatMap`
      The `flatMap` function first maps each element of a collection to a sequence and then flattens the resulting sequences into a single array.
      ```swift
      let arrayOfArrays = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
      let flattenedArray = arrayOfArrays.flatMap { $0 }
      print(flattenedArray) // [1, 2, 3, 4, 5, 6, 7, 8, 9]
      ```

    * `compactMap`
      The `compactMap` function returns an array containing the non-nil results of calling the given transformation with each element of this sequence.
      ```swift
      let numbers = ["1", "2", "three", "4", "five"]
      let mapped = numbers.compactMap { Int($0) }
      print(mapped) // [1, 2, 4]
      ```
    * `first(where:)`
      The `first(where:)` function returns the first element of the collection that satisfies the given predicate.
      ```swift
      let numbers = [1, 2, 3, 4, 5]
      if let firstEven = numbers.first(where: { $0 % 2 == 0 }) {
        print(firstEven) // 2
      }
      ```
    * `forEach`
      The `forEach` function performs a given action on each element of a collection.
      ```swift
      let names = ["Alice", "Bob", "Charlie"]
      names.forEach { name in
        print(name)
      }
      // prints:
      // Alice
      // Bob
      // Charlie
      ```

      This function is similar to a `for-in` loop but provides a more functional approach to iterating over a collection.
